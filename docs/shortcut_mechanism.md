# ショートカットおよびフック機構 仕様書

本文書では、MixedBerryPie がどのようにグローバルキーボードショートカット（トリガー）を処理し、キー出力（アクション）をシミュレートするのかについて、アーキテクチャおよび実装の詳細を定めます。

## 1. コア目標
1. **グローバルトリガー検知**: どのアプリケーションにフォーカスが当たっていても、特定のキー組み合わせ（例: `ctrl+space`）をグローバルに検知する必要があります。
2. **イベント抑制（ブロック）**: トリガーとなるホットキーが検知された際、そのキーイベントはOSレベルで完全に抑制され、現在アクティブなアプリケーションに「貫通」して誤入力されるのを防ぐ必要があります。
3. **アクションの実行**: ユーザーがパイメニュー内の項目を選択した際、アプリケーションは対象のキーストローク（`ctrl+c` などの修飾キーを含む）やアクションを正確にシミュレートし、正しいアクティブアプリケーションに送信する必要があります。
4. **クロスプラットフォーム対応**: 安全なイベント抑制のためにネイティブフックが必須となるWindowsを最優先としつつ、他のOSに対しても `pynput` を経由したフォールバック機構を概念的にサポートします。

## 2. トリガー検知と抑制 (`HookManager`)

`HookManager` (`src/core/hook_manager.py`) はキーボードイベントを監視し、パイメニューを起動する役割を担います。

### 2.1 Windowsネイティブフック (`_NativeWin32Hook`)
`pynput` の `win32_event_filter` を用いて同期的にイベントを抑制しようとすると、スレッドのデッドロックやクラッシュが発生するため、Windows環境では厳密に制御された独自のネイティブ実装を使用します。
- **`WH_KEYBOARD_LL`**: `ctypes.windll.user32.SetWindowsHookExW` を使用して、低レベルキーボードフックを登録します。
- **メッセージポンプ**: フック機構は、Windowsのメッセージポンプ（`PeekMessageW` / `TranslateMessage` / `DispatchMessageW`）を実行する独自のデーモンスレッド内に隔離されています。
- **同期的な抑制**: フックのコールバック (`_hook_callback`) はすべてのキーのPress（押し）/Release（離し）を監視します。イベントが登録済みのトリガーと完全に一致した場合、Pythonのフィルター関数は `False` を返します。それを受けてネイティブフックは即座に `1`（完全な抑制）をOSに返し、イベントが他のアプリケーションへ到達するのを阻止します。
- **シミュレートされたイベントの安全な除外**: アプリケーション自身が生成した疑似的なキーストロークをフックが誤って検知・抑制してしまわないよう、独自の識別子を付与します。
  - **`MAGIC_EXTRA_INFO`**: `win32_input.py` で定義されたマジックナンバー (0x31415926) を `dwExtraInfo` に含めて送信します。フック側でこれをチェックし、一致する場合は無視します。これにより、左手デバイスなどが付与する `LLKHF_INJECTED` フラグとの衝突を避け、確実な識別が可能になります。

### 2.2 修飾キー（モディファイア）状態の追跡
修飾キー（`ctrl`, `alt`, `shift`, `win`）は、押された・離されたタイミングで個々の仮想キーコード（VK）を基に動的に追跡されます。
- 現在の状態は `HookManager._held_modifiers` に保持されます。
- これにより、ユーザーが `space` キーを押した瞬間に、修飾キー群の中で `ctrl` **のみ**がホールド状態になっているかを正確に判定できます。

### 2.3 非Windows用フォールバック (`pynput.keyboard.Listener`)
macOS や Linux では、標準の `pynput` リスナーが使用され、`on_press` および `on_release` メソッドを通じて監視します。※これらのプラットフォームにおける厳密なOSレベルのイベント抑制は、`pynput` 内部の互換性能力に依存します。

## 3. アクションの実行 (`MixedBerryPieApp._do_execute`)

UIからアクションがトリガーされると、`app.py` 経由で実行されます。

### 3.1 修飾キーのリーク（押しっぱなし状態）防止
新しいキーストロークをシミュレートする前に、アプリケーションは必ず `self.hook_manager.release_all_modifiers()` を呼び出します。
- **理由**: ユーザーが修飾キー（例: `ctrl+space`）を使ってメニューを開いたため、物理的な `ctrl` キーはまだ押しっぱなしになっている可能性が高いです。そのまま別のアクション（例: `c`）を入力すると、意図せず `ctrl+c` になってしまいます。
- **解決策**: `pynput.Controller` を用いて、`HookManager._held_modifiers` が現在「押されている」と認識しているすべての修飾キーを**疑似的に離す信号（Release）**を送ります。（これらの疑似イベントは `LLKHF_INJECTED` フラグを持つため、2.1で記した通りフックには捕捉されず無限ループを起こしません）

### 3.2 アクションのフォーマットとシミュレーション
"key" として設定されたアクション（例: `ctrl+c`, `f5`, `shift+a`）は、`src/core/win32_input.py` の `send_pynput_key_safely` を用いてシミュレートされます。
1. **パース（分割）**: ショートカット文字列は `+` 文字を区切りとして分割されます。
2. **Press（押し）シーケンス**: 分割されたリストを順に処理し、機能キー（修飾キー）からメインキーの順で個別に `.press()` 信号（`SendInput`）を送信します。
3. **Release（離し）シーケンス**: 最後にリストを逆順にたどり、完全にシミュレートされた入力シーケンスを綺麗に終了させるため、個別に `.release()` 信号（`SendInput`）を送信します。

すべての `SendInput` 呼び出しには `MAGIC_EXTRA_INFO` が付与されます。

## 4. 検証チェックリスト（今後のデバッグ用）

- [x] `HookManager` は現在ホールドされている修飾キーを正確に分離・追跡できているか？
- [x] `_NativeWin32Hook` は、UIをフリーズ（ハングアップ）させることなく `1` を返してOSイベントを確実にブロックできているか？
- [x] `_NativeWin32Hook` は、アプリが自己発行した `LLKHF_INJECTED` イベントを正しく無視できているか？
- [x] `execute_action` は複数キーからなる文字列（`ctrl+c`等）を正しく分割し、順序通りにPress/Releaseを実行しているか？
- [x] 疑似出力を実行する前に、現在ホールド状態の修飾キーが安全にRelease（解除）されているか？
